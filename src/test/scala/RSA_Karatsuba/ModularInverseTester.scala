package RSA_Karatsuba

import chisel3._
import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec


class ModularInverseTester extends AnyFlatSpec with ChiselScalatestTester {
  behavior of "Modular Inverse Calculator"

  it should "compute Modular Inverse correctly for 7 and 11" in {
    val p = RSAParams(keySize = 30)
    test(new ModularInverse(p)) { dut =>
      dut.io.a.poke(7.U)
      dut.io.m.poke(11.U)
      dut.io.start.poke(true.B)

      var done = false
      while (!done) {
        dut.clock.step(1)
        done = dut.io.done.peek().litToBoolean
      }

      dut.io.result.expect(8.U)
      dut.io.done.expect(true.B)
    }
  }

  it should "compute Modular Inverse correctly for 17 and 31" in {
    val p = RSAParams(keySize = 32)
    test(new ModularInverse(p)) { dut =>
      dut.io.a.poke(17.U)
      dut.io.m.poke(31.U)
      dut.io.start.poke(true.B)

      var done = false
      while (!done) {
        dut.clock.step(1)
        done = dut.io.done.peek().litToBoolean
      }

      dut.io.result.expect(11.U)
      dut.io.done.expect(true.B)
    }
  }

  it should "handle edge case (m=1)" in {
    val p = RSAParams(keySize = 8)
    test(new ModularInverse(p)) { dut =>
      dut.io.a.poke(5.U)
      dut.io.m.poke(1.U)
      dut.io.start.poke(true.B)

      var done = false
      while (!done) {
        dut.clock.step(1)
        done = dut.io.done.peek().litToBoolean
      }

      dut.io.result.expect(0.U)
      dut.io.done.expect(true.B)
    }
  }

  it should "compute Modular Inverse correctly for 1024-bit numbers" in {
    val p = RSAParams(keySize = 1024)
    val a = BigInt("148172056551570744551350648835911030204583474744100105652420281007372334679285291607830366129668242014374636275589314583154688924083532112192298629096650195173503437738099698766110913624313203893881110000048871917934522306164850919159322463662775188054940732067342506728648888323706390232695443447994904812319")
    val m = BigInt("175561489794595055700259409280033738187942028233859365383218025319523512916297269136224123991896723909631516152374562342492281650509969883341814553213372107254384898912110256955529659020732392166857166238989194507031261833781218060084600856053045031831167759477677485319226769226602082982913597916607283523793")
    val expectedInverse = BigInt("28697764882480988963399681431566051086402252285862390570754373233732471579279899317962782702120708542006024388114820943433912970510623254701190548589695927576929264857580131785548123125646186617442261436354807320754521072794266838641919127881289469587109792409874739689060433897220365291000769250609218213307")
    test(new ModularInverse(p)) { dut =>
      dut.io.a.poke(a.U)
      dut.io.m.poke(m.U)
      dut.io.start.poke(true.B)

      // set timeout to 0 (no timeout) for large bit sizes
      dut.clock.setTimeout(0)

      var done = false
      while (!done) {
        dut.clock.step(1)
        done = dut.io.done.peek().litToBoolean
      }

      dut.io.result.expect(expectedInverse.U)
      dut.io.done.expect(true.B)
    }
  }

  it should "compute Modular Inverse correctly for 2048-bit numbers" in {
    val p = RSAParams(keySize = 2048)
    val a = BigInt("32082816578863210832547621476511683494019281277584225213304496514622384663849024298056304470327609063767812250290828826484594836281526164026864235810715483342615041790737254785538556811136187461474654572252591536359498154365865379223138383627894208177011771855990047070696789696771752123207689803499069179651912925460096348680080937041929871220974742146080007134688442799887044851400030014295019156070905923080895412298776499496694323780138252698208782548037412001313487273802085151742147512910241355849050418242538411261057368947586919500769051923572836840277378196973513755244979229719684733614672656351506958396153")
    val m = BigInt("30721494555791146044187305831630481702190593369555992676893558060815400272714940947736684488463251280632508616532730865420699936181933399719661177630856575742521889383694399778178935221948602019201791550624802927244526774956095818355344296809548051825297745196299471117137988735920830425264557112081464327894399963006686700305942533088488019807882517161664407471698887311374569822976741116780266493426282180292675234400649031114799453493184024560253011960384260873923229900626390125613951912799914912293578178046474100479351167918998018205654672464645265978413229874137152174191097847036678615519201911892485218160513")
    val expectedInverse = BigInt("23734993296352039345530392608140806538872838207887492275874322548767273101340467370191805164191811576533749021205919391015205031162751992593416325103633921118017680458654514459313048767893242451331224722169474334476977842570439307932172457525714375098385801271952564259519918583363970128845454401401925674706684226704455816929167876099141788267459402211023221767036579627920130505199691167277581422668669030717877036806345221926203901823682833933401512838752303357263317970987316098376194581546673827001267488597791729878771848598002124721046704187612007248846524689801859346792378782994041454385509828592604096915777")
    test(new ModularInverse(p)) { dut =>
      dut.io.a.poke(a.U)
      dut.io.m.poke(m.U)
      dut.io.start.poke(true.B)

      // set timeout to 0 (no timeout) for large bit sizes
      dut.clock.setTimeout(0)

      var done = false
      while (!done) {
        dut.clock.step(1)
        done = dut.io.done.peek().litToBoolean
      }

      dut.io.result.expect(expectedInverse.U)
      dut.io.done.expect(true.B)
    }
  }
}
