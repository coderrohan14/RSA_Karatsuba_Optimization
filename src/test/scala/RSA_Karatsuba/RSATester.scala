package RSA_Karatsuba

import chisel3._
import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec

class RSATester extends AnyFlatSpec with ChiselScalatestTester {


  behavior of "RSA"

  it should "work for 128 bits" in {
    val p = RSAParams(keySize = 128)
    test(new RSA(p)) { rsa =>
      val prime1 = BigInt("3253198847").U
      val prime2 = BigInt("3512304833").U
      val msg = BigInt("423489385").U
      val expN = BigInt("11426226033028127551").U
      val expE = BigInt("3").U
      val expD = BigInt("7617484017508415915").U
      val expEnc = BigInt("2071381737345430339").U
      val expDec = BigInt("423489385").U

      rsa.rsaIO.primeNum1.poke(prime1)
      rsa.rsaIO.primeNum2.poke(prime2)
      rsa.rsaIO.message.poke(msg)
      rsa.rsaIO.start.poke(true.B)
      rsa.rsaIO.done.expect(false.B)

      var done = false
      while (!done) {
        rsa.clock.step(1)
        done = rsa.rsaIO.done.peek().litToBoolean
      }

      rsa.rsaIO.done.expect(true.B)
      rsa.rsaIO.publicKeyN.expect(expN)
      rsa.rsaIO.publicKeyE.expect(expE)
      rsa.rsaIO.privateKeyD.expect(expD)
      rsa.rsaIO.encrypted.expect(expEnc)
      rsa.rsaIO.decrypted.expect(expDec)
    }
  }

  it should "work for 1024 bits" in {
    val p = RSAParams(keySize = 1024)
    test(new RSA(p)) { rsa =>
      val prime1 = BigInt("102313201298669803767820592453497775466215672578841135775347924175090742708007").U
      val prime2 = BigInt("108211949078591144736507583506047580770793751322966701196295821335272774895079").U
      val msg = BigInt("839523785925809").U
      val expN = BigInt("11071510928999302184882603997347323184270663939644984180978918706605897969356746326750416908769697242311974678270868441805096486261976970896825793758197553").U
      val expE = BigInt("3").U
      val expD = BigInt("7381007285999534789921735998231548789513775959763322787319279137737265312904357201066693098547461942757343421943087621587463118950003551434210286827062979").U
      val expEnc = BigInt("591696521424964770656405006514041285344250129").U
      val expDec = BigInt("839523785925809").U

      rsa.rsaIO.primeNum1.poke(prime1)
      rsa.rsaIO.primeNum2.poke(prime2)
      rsa.rsaIO.message.poke(msg)
      rsa.rsaIO.start.poke(true.B)
      rsa.rsaIO.done.expect(false.B)

      // set timeout to 0 (no timeout) for large bit sizes
      rsa.clock.setTimeout(0)

      var done = false
      while (!done) {
        rsa.clock.step(1)
        done = rsa.rsaIO.done.peek().litToBoolean
      }

      rsa.rsaIO.done.expect(true.B)
      rsa.rsaIO.publicKeyN.expect(expN)
      rsa.rsaIO.publicKeyE.expect(expE)
      rsa.rsaIO.privateKeyD.expect(expD)
      rsa.rsaIO.encrypted.expect(expEnc)
      rsa.rsaIO.decrypted.expect(expDec)
    }
  }


  it should "work for 2048 bits" in {
    val p = RSAParams(keySize = 2048)
    test(new RSA(p)) { rsa =>
      val prime1 = BigInt("12726495879108145317389526052489568525771271260927975617327718751288778229283267473316909835725368667377582345110438662609623130731646083048998221203088707").U
      val prime2 = BigInt("13330688456253139745175123964928215031309653995352226495125237439461902888458992213399512171662451924335791884917375068595672026090869309081552107915077333").U
      val msg = BigInt("27438192748793213123").U
      val expN = BigInt("169652951704180106281904712154292877861075931874596846290741093016241710461679123229141106425722774343087956584099743498080358141031705597481522743905811872533054690831370169026760411537604571519080335708599729222558308938550445321317409954929130627267214277101590715819109315332027025531222544022114363978431").U
      val expE = BigInt("5").U
      val expD = BigInt("67861180681672042512761884861717151144430372749838738516296437206496684184671649291656442570289109737235182633639897399232143256412682238992609097562324738590348142188034042584844157647928405775262031771359046707840847275147731031623089295402849295778649025490944275202151244014748081206332165388714098324957").U
      val expEnc = BigInt("15551687223481102812243217939132550879987940148796870125474748389745584091227008001500603220721843").U
      val expDec = BigInt("27438192748793213123").U

      rsa.rsaIO.primeNum1.poke(prime1)
      rsa.rsaIO.primeNum2.poke(prime2)
      rsa.rsaIO.message.poke(msg)
      rsa.rsaIO.start.poke(true.B)
      rsa.rsaIO.done.expect(false.B)

      // set timeout to 0 (no timeout) for large bit sizes
      rsa.clock.setTimeout(0)

      var done = false
      while (!done) {
        rsa.clock.step(1)
        done = rsa.rsaIO.done.peek().litToBoolean
      }

      rsa.rsaIO.done.expect(true.B)
      rsa.rsaIO.publicKeyN.expect(expN)
      rsa.rsaIO.publicKeyE.expect(expE)
      rsa.rsaIO.privateKeyD.expect(expD)
      rsa.rsaIO.encrypted.expect(expEnc)
      rsa.rsaIO.decrypted.expect(expDec)
    }
  }

  it should "work for 4096 bits" in {
    val p = RSAParams(keySize = 4096)
    test(new RSA(p)) { rsa =>
      val prime1 = BigInt("140097194970527436952438604602051155751499089335539344962667863658956829013660433431046441839445397019562491263047240861596165755997573185451702575703507906201131740624073625367444230043075970060669249244858282690762818089079738877457394291100105979248259281744162256302992956543068696255959237878252882495109").U
      val prime2 = BigInt("146649923036635658558961885291710844412566702659591774951513838781629046847242766416912140825371938460808753950605829546797171198320787945192590482870960684024926488805009233069108941077037696192497574518651494583315009862954806325712800913482566746453173735532367251191168433443505311341786760303107623529147").U
      val msg = BigInt("7248284728472018345").U
      val expN = BigInt("20545242860076388898471031511730757265054610140776911178706111696205859212016675273668518599304797777458985095381110709010032982613666359026998483534988794149728653057209953040395705782048864117705978383033875935056303426719179270588086674877815522129242358703237024133692849731617070935739897223548228254667966557002827108589692150636604749509752115721829885396045701800855474784339557242447006300193478369062132626888846783204868993170634149281064550491823261502195220697019740082677390965083936942068909395037047998305109574043735411187971218817940889015596654357223428419744712062075788483878408394676129546442023").U
      val expE = BigInt("5").U
      val expD = BigInt("12327145716045833339082618907038454359032766084466146707223667017723515527210005164201111159582878666475391057228666425406019789568199815416199090120993276489837191834325971824237423469229318470623587029820325561033782056031507562352852004926689313277545415221942214480215709838970242561443938334128936952800607885930891967296508450088026592505752829957900852565678912059048933345087192425559428630517196620149056829005116227677885393729789472890252154459949275747181497480554394334544502676378293965489445542764122932618619047655020519590880614168014929773937132803968139347350330403253528685768397437896861424250661").U
      val expEnc = BigInt("20006735252981289770823521265276713268581321398549503747963243337623653904350696402533154215625").U
      val expDec = BigInt("7248284728472018345").U

      rsa.rsaIO.primeNum1.poke(prime1)
      rsa.rsaIO.primeNum2.poke(prime2)
      rsa.rsaIO.message.poke(msg)
      rsa.rsaIO.start.poke(true.B)
      rsa.rsaIO.done.expect(false.B)

      // set timeout to 0 (no timeout) for large bit sizes
      rsa.clock.setTimeout(0)

      var done = false
      while (!done) {
        rsa.clock.step(1)
        done = rsa.rsaIO.done.peek().litToBoolean
      }

      rsa.rsaIO.done.expect(true.B)
      rsa.rsaIO.publicKeyN.expect(expN)
      rsa.rsaIO.publicKeyE.expect(expE)
      rsa.rsaIO.privateKeyD.expect(expD)
      rsa.rsaIO.encrypted.expect(expEnc)
      rsa.rsaIO.decrypted.expect(expDec)
    }
  }

}
